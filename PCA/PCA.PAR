#include "npca.h"
#include "pcadef.h"
#define itoa
#define atoi
#define create
#define open
#define read
#define stricmp
#define close
#define write
#include "mod.h"
#include "video.h"
#define NULL 0L

char display_mail=DMAIL_DEFAULT;
char display_work=DWORK_DEFAULT;

char far *devices[MAX_DEVICES];
char device_class[MAX_DEVICES];

/*This module contains all routines needed to talk to the PCA card.
  Such as get value from mailbox, send and receive DMA, kick watchdog,
*/

unsigned char dma_pages[4]={0,0x8b,0x89,0x8a};
unsigned char dma_base[4]={0,0xc4,0xc8,0xcc};
short mail[256],_mail[256];
short packet_cnt=0;
short got_error=false;
char error_latch=0;
char destroy_next=false;
window_type far *output=0L,far *nodes=0L;
module far *input_task;

Node far *first_work=0L;
short kill_children=false;
short base;
char filling=0;
short thread=0;
long eventime,oddtime;

short IRQ,DMP,priority;
unsigned char int_work;
short input_DMA,output_DMA;
short control,config,PCA_num;
short status;
char far *fill_name;
char do_transfer=false; /*flag for iRQ routine to initiate DMA send on
                          input TI interrupt*/

extern void connect_int(short IRQ);
extern void disconnect(short IRQ);
extern short read_mailbox(int number); /*returns actual value in mailbox*/

extern short sread_mailbox(int number);  /*returns byte_reversed value in
                                           mailbox for mathematical oper-
                                           ations*/

extern long  lread_mailbox(int number); /*returns byte reversed long value
                                          from mailbox nuber...*/

extern short read_port(short offset); /*returns the value of a port*/
extern void write_port(short offset,short value); /*sets value of a port*/
extern void write_mail(int number,short data); /*write a value into a mailbox*/
extern short out_port(short offset,short value); /*set the value of a port*/
extern void outportb(short port,char value); /*put out a byte to the
                                               specified port*/
extern char inportb(short port);
extern void read_all_mail(short far *mail_array); /*read all 256 mailboxes
                                                    into the specified
                                                    array*/

extern short copy_mail(short start,Node far **where); /*copy data from
                                                         the mailbox to
                                                         the appropriate
                                                         queue_enry*/

extern void send_mail(short start,void far *what);


extern void shiftrong(unsigned long far * value,char places);
extern void shiftlong(unsigned long far * value,char places);

Node blank_work;

char page(void far*address)
{
  unsigned long temp=(unsigned long)0|(unsigned short)address;
  (long)address^=(unsigned short)address;
  shiftrong((unsigned long far *)&address,12);
  temp+=(unsigned long)address;
  shiftrong((unsigned long far *)&temp,16);
  return ((unsigned char)temp);
}

short ofs(void far*address)
{
  unsigned long temp=(unsigned long)0|(unsigned short)address;
  (unsigned long)address^=(unsigned short)address;
  shiftrong((unsigned long far *)&address,12);
  temp+=(unsigned long)address;
  return ((unsigned short)temp);
}

void mask_DMA(void)
{
//  outport(0xd4,0xff);  /*mask all dmas*/
}

short Initiate_DMA(char channel,
                   unsigned short far *buffer,
                   unsigned short count,
                   char write_mem,char start_now)
{
  unsigned char pg=page(buffer);
  unsigned short offset=ofs(buffer);
  if ((offset&1)||   /*if the buffer starts on an odd address we cannot*/
      (channel<5)||  /*send it... therefore return a false...or if the */
      (channel>8))   /*DMA channel specified was an unsupported one.   */
    return(false);

  offset>>=1;        /*convert byte offset into word offset*/

  if (pg&1)          /*if the page is odd then we need to carry the bit into*/
    offset|=0x8000;  /* The offset*/

  channel-=4;
  if (display_work)
    displayln(nodes,"Ct:*h Ofs:*h Pg:*n Ch:*d w:*d\n",
                    count,offset,pg,channel,write_mem);
  count--;
  outportb(dma_pages[channel],pg);
  outportb(0xd8,0xff);           /*clear byte flip-flop*/
  outportb(dma_base[channel],(char)offset);
  outportb(dma_base[channel],offset>>8);
  outportb(dma_base[channel]+2,(char)count);
  outportb(dma_base[channel]+2,count>>8);

  outportb(0xd0,0x00);    /*command out*/

  if (write_mem)
  {
    outportb(0xd6,0x44|channel);
    control|=1;
    outportb(0xd4,channel);
  }
  else
  {
    outportb(0xd6,0x48|channel);
    control|=2;
    if (start_now)
      outportb(0xd4,channel);
    else
      do_transfer=channel;
  }
  return(true);
}

short process_ints(void)
{
#define SetInt(a) if (IntQ&INT_##a) int_work|=a;
  char IntQ=read_port(INTR_QUEUE);
  if (!IntQ)
    return(false);
  SetInt(EVENTC);
  SetInt(ODDTC);
  SetInt(EVENTI);
  SetInt(ODDTI);
  SetInt(EVENSEL);
  SetInt(ODDSEL);
  SetInt(EVENTERM);
  SetInt(ODDTERM);
  write_port(INTR_QUEUE,IntQ);
  return(true);
}

void show_error(window_type far *window,char *line)
{
  char attr=getattr(window);
  setattr(window,RED|ON_GREY);
  displayln(window,line);
  setattr(window,attr);
  moddisplay(window,SELECT_WINDOW,END_MOD);
}

#define Watch_Dog(what,time,status) { time_struc End,Current; \
    gettime(&End);                                            \
    End+=time;                                                \
    while (!(what))                                           \
    {                                                         \
      gettime(&Current);                                      \
      if (Current>=End)                                       \
      {                                                       \
        status=false;                                         \
        break;                                                \
      }                                                       \
      Relinquish(0L);                                         \
    }                                                         \
  }


short Send(unsigned short far *buffer,unsigned long count)
{
  short term=0;
  short xfr_status=true;
  time_struc endtime,curtime;
  unsigned long total_count=(count>>1)+(count&1);
  unsigned short work_count=0;
  unsigned short offset;
  unsigned short got_busy=0;
  char first=true;
  long buf_address=(short)buffer+(((long)buffer&0xffff0000)>>12);
  if (count)
  do
  {
    if (work_count)
    {
      buf_address+=(work_count<<1);
    }
    (long)buffer=((buf_address&0xf0000)<<12)+(unsigned short)buf_address;
    offset=(short)buffer;
    if (offset&1)
      return(false);
    work_count=0x8000-(offset>>1);
    if (work_count<=total_count)
    {
      total_count-=work_count;
    }
    else
    {
      work_count=total_count;
      total_count=0;
    }
    Initiate_DMA(output_DMA,
                 buffer,
                 work_count,
                 READ_MEM,(first?false:true));

    first=false;
    out_port(CONTROL,control);
    gettime(&endtime);
    endtime+=(10+(work_count>>7));
    while ((!(int_work&(ODDTC|ODDTERM)))&&
               ((read_port(STATUS)&(0x2|got_busy))==(0x2|got_busy)))
    {
      if (read_port(STATUS)&0x400)
      {
        got_busy=0x400;
        if (do_transfer)  /*If Controller is busy,
                                                     but, it hasn't been started
                                                     then start the DMA*/
        {
          outportb(0xd4,do_transfer);
          do_transfer=0;
        }
      }
      Relinquish(0L);
      gettime(&curtime);
      if (curtime>endtime)
        break;
    }
    control&=~2;
    if ((read_port(STATUS)&0x2)!=0x2)
    {
      show_error(nodes,"MC on P->M\n");
      xfr_status=false;
      total_count=0;
    }
    if (display_work)
    {
      if (int_work&ODDTERM)
        displayln(nodes,"MT");
      if (int_work&ODDTC)
        displayln(nodes,"TC");
    }
    do_transfer=0;                /*this is after we get Terminate / TC */
    if (int_work&ODDTERM)
    {
      term=read_port(IN_TERM);
      if (term&0x1)
      {
        show_error(nodes,"Abort DMP P->M.");
        displayln(nodes,"\nAbort:*h\n",term);
        total_count=0;
        xfr_status=false;
      }
    }
    if (xfr_status)
    {
      Watch_Dog(int_work&ODDTC,100,xfr_status);
      if (!xfr_status)
      {
        show_error(nodes,"Lost TC\n");
        total_count=0;
      }
    }
    int_work&=~(ODDTC);
  }
  while (total_count);
  if (xfr_status)
  {
    Watch_Dog(int_work&ODDTERM,200,xfr_status);
    if (xfr_status)
    {
      term=read_port(IN_TERM);
      if (term&0x1)
      {
        show_error(nodes,"Abort DMP P->M..");
        displayln(nodes,"\nAbort:*h\n",term);
        xfr_status=false;
      }
    }
    else
    {
      show_error(nodes,"Lost MT\n");
    }
  }
  int_work&=~(ODDTERM);
  control&=~2;
  return(xfr_status);
}


short Receive(unsigned short far *buffer,unsigned long count)
{
  short term=0;
  short xfr_status=true;
  time_struc endtime,curtime;
  unsigned long total_count=(count>>1)+(count&1);
  unsigned short work_count=0;
  unsigned short offset,cstatus;
  long buf_address=(short)buffer+(((long)buffer&0xffff0000)>>12);
  if (got_error&EMPTYINPUT)
    return(false);
  do
  {
    if (work_count)
    {
      buf_address+=(work_count<<1);
    }
    (long)buffer=((buf_address&0xf0000L)<<12)+(unsigned short)buf_address;
    offset=(short)buffer;
/*    if (work_count&&!offset)
      asm int 3; */
    if (offset&1)
      return(false);
    work_count=0x8000-(offset>>1);
    if (work_count<=total_count)
    {
      total_count-=work_count;
    }
    else
    {
      work_count=total_count;
      total_count=0;
    }
    int_work&=~(EVENTC|EVENTERM);
    Initiate_DMA(input_DMA,
                 buffer,
                 work_count,
                 WRITE_MEM,true);

    out_port(CONTROL,control);
    gettime(&endtime);
    endtime+=(10+(work_count>>7));
    while ((!(int_work&(EVENTERM|EVENTC)))&&
            (((cstatus=read_port(STATUS))&0x6)==0x6)
           )
    {
      Relinquish(0L);
      gettime(&curtime);
      if (curtime>endtime)
        break;
    }
    control&=~1;

    if( (((cstatus=read_port(STATUS))&0x2)!=0x2) ||
        (!(int_work&(EVENTC|EVENTERM)))
      )
    {
      if(!(int_work&(EVENTC|EVENTERM))) show_error(nodes,"NOT BUSY ON P<-M");
      show_error(nodes,"MC on P<-M");
      xfr_status=false;
      total_count=0;
    }

    if (display_work)
    {
      if (int_work&EVENTERM)
        displayln(nodes,"MT");
      if (int_work&EVENTC)
        displayln(nodes,"TC");
    }


    if (int_work&EVENTERM)
    {
      term=read_port(OUT_TERM);
      if (term&0x1)
      {
        show_error(nodes,"Abort DMP P<-M.");
        displayln(nodes,"\nAbort:*h\n",term);
        total_count=0;
        xfr_status=false;
      }
      while (read_port(STATUS)&1)
      {
        read_port(DATA);
        Relinquish(0L);
      }
      if (total_count||(((unsigned char)inportb(dma_base[input_DMA]+2)&
                         (unsigned char)inportb(dma_base[input_DMA]+2))==
                         (unsigned char)0xff))
           /*we still had data left when Modcomp sayd stop*/
      {
        xfr_status=false;
        total_count=0;
        show_error(nodes,"Modcomp Xfrd Shrt");
      }
    }
    if (xfr_status)
    {
      Watch_Dog(int_work&EVENTC,100,xfr_status)
      if (!xfr_status)
      {
        show_error(nodes,"Lost TC.\n");
        total_count=0;
      }
    }
    int_work&=~(EVENTC);
  }
  while (total_count);
  if (xfr_status)
  {
    Watch_Dog(int_work&EVENTERM,200,xfr_status);
    if (xfr_status)
    {
      term=read_port(OUT_TERM);
      if (term&0x1)
      {
        displayln(nodes,"Abort DMP P<-M..");
        total_count=0;
        xfr_status=false;
      }
    }
    else
    {
      show_error(nodes,"Lost MT.\n");
    }
  }
  int_work&=~(EVENTERM);
  control&=~1;
  return(xfr_status);
}


void do_fill(char far *filename)
{
  /*this routine is called with the name of the file in which the fill data
    is stored... the file must contain the count of the words to transfer,
    which is stored in the first word.*/
  unsigned short far *fill_data;
  short handle;
  unsigned short size;
/*  asm int 3;*/
  handle=open(filename,0); /*open for read access only */
  if (handle==-1)
    show_error(nodes,"Couldn't open Fill File!");
  else
  {
    if (!read(&size,2,handle))
      show_error(nodes,"Couldn't read Fill File!");
    else
    {
      size=((size<<8)|(size>>8))*2;
      if (!(fill_data=Allocate(size)))
        show_error(nodes,"Couldn't allocate Fill Space!");
      else
      {
        if (read(fill_data,size,handle)!=size)
          show_error(nodes,"Fill file shorter than expected!");
        else
        {
          /*now we have the data and the count of the transfer, and
            all we need to do is call send to give the data to the
            modcomp!*/
          Send(fill_data,size);
          int_work&=~(ODDTI|ODDTC|ODDTERM);
        }
        Free(fill_data);
      }
    }
    close(handle);
  }
}

void destroynode(Node far *node)
{
  if (node==&blank_work)
    return;
  if (node->Tracking.Status&SAVE_WHEN_DONE)
    return;
  if (!(node->Tracking.Status&USER_BUFFER)&&node->Data)
    Free(node->Data);
  if (node->Return.Extended_mail)
    Free(node->Return.Extended_mail);
  if (node->Tracking.prior)
    node->Tracking.prior->Tracking.next=node->Tracking.next;
  else
    first_work=node->Tracking.next;
  if (node->Tracking.next)
    node->Tracking.next->Tracking.prior=node->Tracking.prior;
  Free(node);
}

#define time_stamp(mark) { }
#define otime_stamp(mark) { long temp_time;                                 \
    gettime((time_struc far *)&temp_time);                                 \
    displayln(nodes,"*h "mark" Time:*h\n",(short)temp->Node.Node_Address,  \
                            (short)(temp_time-temp->Tracking.start_time)); \
    }


void do_output()
{
  Node far *temp;
  while (true)
  {
    temp=Import(device_name);
    if (kill_children)
    {
      destory();
      status&=~(EVENBUSY|ODDBUSY);
      kill_children=false;
    }
    time_stamp("RCV");
    {
      if (fork(PARENT)==0)  /*take childs path... used to be...
                              Fork(child)==1;        */
      {
        if (temp->Node.Node_Address)
        {
          if(display_work)
          {
//            displayln(nodes,"-*h *n RC:*n *n\n S:*h *h *h\n",
//                                          (short)temp->Node.Node_Address,
//                                          temp->Node.Rex,
//                                          temp->Return.Opcode,
//                                          temp->Node.Channel,
//                                          temp->Return.Status,
//                                          temp->Return.Byte_count,
//                                          temp->Return.XStatus);
          }
          if (temp->Tracking.Side)
          {
            if (display_work)
              displayln(nodes,"Out *n\n",status);
            while (status&ODDBUSY)
            {
              Relinquish(0L);
              if (!temp->Node.Node_Address)
                goto end_node;
            }
            status|=ODDBUSY;
            if (display_work)
              displayln(nodes,"*H Deposited\n",temp->Node.Node_Address);
            time_stamp("Odd");
            {
              short mail_retry=0;
send_mail_again:
              do
              {
                while ((read_port(STATUS)&0x1c00)||(read_port(IN_SELECT)&0x2))
                          /*while Interal/Busy/external
                           or inprocess of being made busy*/
                {
                  Relinquish(0L);
                  if (!temp->Node.Node_Address)
                  {
                    status&=~ODDBUSY;
                    goto end_node;
                  }
                }
                if (!temp->Node.Node_Address)
                {
                  status&=~ODDBUSY;
                  goto end_node;
                }
                send_mail(PC_mail_out,temp);
              }
              while ((read_port(STATUS)&0x1c00)||(read_port(IN_SELECT)&0x2));
                                                                  /*check status
                                                                   to make sure that
                                                                   it really is
                                                                   safe. */
              out_port(CONTROL,control|EXTERNAL_ODD);  /*give him the external*/
              time_stamp("OSI");
              if (display_work)
                   displayln(nodes,"SI ");
              switch(temp->Return.Opcode)
              {
                case SLOUGH:
                  temp->Tracking.Status&=~WORK_IN_MAIL;
                  break;
                case COMPLETE:
                  if (temp->Data&&temp->Node.Node_Address)
                  {
                    char send_okay;
                    if (display_work)
                      displayln(nodes,"SN ");
                    if (!(send_okay=Send(temp->Data,temp->Return.Byte_count)))
                    {
                      if (mail_retry++<2)
                        goto send_mail_again;
                      temp->Return.XStatus=0;
                      temp->Return.Status=0x9100;
                      temp->Return.Byte_count=0x9067;
                      /*because we free the data, we will not return this way.
                        There is no way out but to send the mail and free
                        the node. */
                      Free(temp->Data);
                      temp->Data=NULL;
                      goto send_mail_again;
                    }
                    if (send_okay&&temp->Tracking.Status&TERM_WHEN_DONE)
                      out_port(CONTROL,control|EXTERNAL_ODD);
                  }
                  if (display_work)
                    displayln(nodes,"UL ");
                  destroynode(temp);
                  break;
              }
            }
            status&=~ODDBUSY;
          }
          else
          {
//            if (display_work)
//              displayln(nodes,"In *n\n",status);
            while (status&(EVENBUSY))
            {
              Relinquish(0L);
              if (!temp->Node.Node_Address)
                goto end_node;
            }
            status|=EVENBUSY;
            if (display_work)
              displayln(nodes,"*H Deposited\n",temp->Node.Node_Address);
            time_stamp("Evn");
            {
              do
              {
                while (((read_port(STATUS)&0x1c)||(read_port(OUT_SELECT)&0x2))
                        &&temp->Node.Node_Address)
                          /*while Interal/Busy/external
                           or inprocess of being made busy*/
                  Relinquish(0L);
                if (!temp->Node.Node_Address)
                {
                  status&=~EVENBUSY;
                  goto end_node;
                }
                send_mail(PC_mail_in,temp);
              }
              while (((read_port(STATUS)&0x1c)||(read_port(OUT_SELECT)&0x2))
                      &&temp->Node.Node_Address);
                   /*check status to make sure that it really is safe. */

              if (!temp->Node.Node_Address)
              {
                status&=~EVENBUSY;
                goto end_node;
              }
              out_port(CONTROL,control|EXTERNAL_EVEN);  /*give him the external*/
              time_stamp("ESI");
              switch(temp->Return.Opcode)
              {
                case SLOUGH:
                  temp->Tracking.Status&=~WORK_IN_MAIL;
                  break;
                case COMPLETE:
                  destroynode(temp);
                  break;
              }
            }
            status&=~EVENBUSY;
          }
        }
        else
        {
end_node:
          /*Node address was zero, so just deallocate it.
            If returning complete. */
          displayln(nodes,"dealloc Term Node.");
          if (temp->Return.Opcode==COMPLETE)
            destroynode(temp);
        }
        perish();
      }
    }
  }
}

void proc_in_mail(short from,char dma,char side)
{
  Node far *temp;
  Node far *victim;
  if (destroy_next)
  {
    destroy_next=false;
    return;
  }
  /*read mailboxes into a work queue entry - in, and create the
     work packet (allocated here because it knows how many extra words
     there are) */
  asm push ss
  if (!copy_mail(from,(Node far **)&temp))
  {
    asm add sp,2
    show_error(nodes,"Mail Size Expected");
    return;           /*if there wasn't actually mail*/
  }
  asm add sp,2
  if (side)
    temp->Tracking.start_time=oddtime;
  else
    temp->Tracking.start_time=eventime;
  temp->Tracking.next=first_work;  /*put the work in our list */
  temp->Tracking.prior=NULL;
  if (first_work)
    first_work->Tracking.prior=temp;
  first_work=temp;

  /*if there is a data transfer expexted, allocate the buffer*/
  if (temp->Node.Byte_count)
  {
    while (!(temp->Data=Allocate(temp->Node.Byte_count)))
      Relinquish(0L);
  }
  else
    temp->Data=NULL;
  temp->Tracking.Source=device_name;
  temp->Tracking.Side=side;
  temp->Tracking.Status=0;
  temp->Return.Status=0;
  temp->Return.XStatus=0;
  temp->Return.Byte_count=temp->Node.Byte_count;
  temp->Return.Extended_Size=0;
  temp->Return.Extended_mail=NULL;
  temp->Data_handle.Preamble=NULL;
  temp->Data_handle.index=0;

  /* get the data if indicated to DMA it in*/
  if (dma&&temp->Node.Byte_count)
  {
    if (display_work)
       displayln(nodes,"**");
    if (!Receive(temp->Data,temp->Node.Byte_count))
    {
      destroynode(temp);
      return;
    }
  }
  else
    if (display_work)
      displayln(nodes,"+");

  if (display_work)
  {
    displayln(nodes,"*h *n to:*n *n\n",
                     (short)temp->Node.Node_Address,
                     temp->Node.Rex,
                     temp->Node.Transport,
                     temp->Node.Channel);
  }
  if (stricmp(devices[temp->Node.Transport],device_name))
        /*if anything other than a message to me, ship it
                           to specified device.*/
  {
    if (!Export(devices[temp->Node.Transport],(unsigned char far *)temp)||
         temp->Node.Transport>MAX_DEVICES)
    {
      temp->Return.Opcode=1;
      temp->Return.Status=0x0030;
      temp->Return.Byte_count=0;
      temp->Return.XStatus=0;
      if (temp->Data)
      {
        Free(temp->Data);
        temp->Data=0;
      }
      Export(device_name,temp);
    }
  }
  else
  {
          /*do the Node.Rex myself*/
    switch(temp->Node.Rex&0xf)
    {
      case TERMINATE:  /*Terminate operation*/
             {
               Node far *victim=first_work;
               displayln(nodes,"Terminating...");
               while (victim)
               {
                displayln(nodes,"Checking- *H ",temp->Node.Node_Address);
                if (victim->Node.Node_Address==temp->Node.Node_Address&&
                    victim!=temp)
                {
                  displayln(nodes,"zeroing address...");
                  victim->Node.Node_Address=0L;
                  if (victim->Tracking.prior)
                    victim->Tracking.prior->Tracking.next=
                        victim->Tracking.next;
                  else
                    first_work=victim->Tracking.next;
                  break;
                }
                victim=victim->Tracking.next;
               }
               displayln(nodes,"returning");
               temp->Return.Opcode=1;
               if (temp->Data)
               {
                 Free(temp->Data);
                 temp->Data=0L;
               }
               temp->Return.Status=0;
               temp->Return.Byte_count=0;
               temp->Return.XStatus=0;
               Export(device_name,temp);
             }
             break;
      default:
               temp->Return.Opcode=1;
               if (temp->Data)
               {
                 Free(temp->Data);
                 temp->Data=0L;
               }
               temp->Return.Status=0x0030;
               temp->Return.Byte_count=0;
               temp->Return.XStatus=0;
               Export(device_name,temp);
    }
  }
  packet_cnt++;
}

void do_input()
{
  char charac;
  input_task=my_TCB;
top:

  while (!keypressed(output)&&!keypressed(nodes))
  {
    out_port(CONTROL,control);
    if (int_work&(EVENSEL|EVENTI))
    {
      proc_in_mail(Mod_mail_in,int_work&EVENTI,0);
      int_work&=~(EVENSEL|EVENTI);    /*get rid of bits*/
    }
    if (int_work&ODDSEL)
    {
      proc_in_mail(Mod_mail_out,0,1);
      int_work&=~(ODDSEL);            /*get rid of bits*/
    }
    if (int_work&ODDTI)
    {
      if (filling)
      {
        do_fill(fill_name);
        filling=false;
        while (process_ints());
      }
      int_work&=~ODDTI;
    }
    asm cli;   /* Relinquish's turn on interupts again. */
    if (!int_work&&
        !read_mailbox(Mod_mail_in)&&
        !read_mailbox(Mod_mail_out))
      Relinquish(-1000L);
    else
      Relinquish(0L);

    if ((read_port(STATUS)&0x8082)!=0x8082)
    {
      Node far *temp=first_work;
      if (!(read_port(STATUS)&0x8000)&&!(error_latch&ODDERROR))
      {
        show_error(nodes,"Error on Odd Channel.");
        error_latch|=ODDERROR;
      }
      if (!(read_port(STATUS)&0x0080)&&!(error_latch&EVENERROR))
      {
        show_error(nodes,"Error on Even Channel");
        if ((!(got_error&EMPTYINPUT)) && fork(CHILD))
        {
          got_error|=EMPTYINPUT;
          while ((read_port(STATUS)&0x1))
          {
            Relinquish(0L);
            read_port(DATA);
          }
          got_error&=~EMPTYINPUT;
          perish();
        }
        error_latch|=EVENERROR;
      }
      if (!(read_port(STATUS)&0x0002))
      {
        show_error(nodes,"Card Disarmed");
        kill_children=true;
        Export(device_name,&blank_work);
        if (error_latch&DISARMERROR)
        {
          Relinquish(-500L);
        }
        error_latch|=DISARMERROR;
        /*remove all prior terminates*/
        write_port(MAIL_ADDRESS,PC_mail_out);
        write_port(MAIL_DATA,0);    /*make sure outgoing mail is marked read*/
        write_port(MAIL_ADDRESS,PC_mail_in);
        write_port(MAIL_DATA,0);    /*make sure outgoing mail is marked read*/
        write_port(INTR_QUEUE,read_port(INTR_QUEUE));
        /*Kill all outstanding nodes */
        while (temp)
        {
          temp->Node.Node_Address=0;
          temp=temp->Tracking.next;
        }
      }
      int_work=0;
      do_transfer=0;
      out_port(CONFIGURATION,config);
      out_port(OUT_CHANNEL,0);
      out_port(IN_CHANNEL,0);
      mask_DMA();
      control=4;
    }
    else
      error_latch=0;
  }
  if (keypressed(output))
    charac=readch(output);
  if (keypressed(nodes))
    charac=readch(nodes);

  if (charac=='o' || charac=='O')
  {
    asm int 3;
    goto top;
  }

  if (charac==27) Exit(2);

  if (charac==0)                 /* process extended characters */
  {
    if (keypressed(output))
      charac=readch(output);
    if (keypressed(nodes))
      charac=readch(nodes);

    if (charac=='D')
    {
      display_work=!display_work;
      if (display_work)
      {
        clr_display(nodes,1);
        position(nodes,0,0);
      }
      goto top;
    }

    if (charac=='C')
    {
      display_mail=!display_mail;
      goto top;
    }
/*    if (charac=='B')
    {
      destroy_next=true;
      goto top;
    }*/
    charac=0;
  }

  Relinquish(0);              /*let others look at it */
  goto top;
}

cleanup(void,dualpca,(void))
{
  Load_DS;
  disconnect(IRQ);
  Restore_DS;
}

short r1,r2,r3,r4,r5,r6,r7,r8,r9;
short _r1,_r2,_r3,_r4,_r5,_r6,_r7,_r8,_r9;

void do_diags()
{
  short i;
  short cnt;
  r1=~_r1;       r4=~_r4;    r7=~_r7;
  r2=~_r2;       r5=~_r5;    r8=~_r8;
  r3=~_r3;       r6=~_r6;    r9=~_r9;

  change_priority(255);

  while (true)
  {
    do
      Relinquish(-255);     /*relinquish for 255 passes of the swapper*/
    while(!display_mail);
    {
      read_all_mail(mail);
      for (i=0;i<4;i++)
        for (cnt=0;cnt<16;cnt++)
          if (mail[(i*0x40)+cnt]!=_mail[(i*0x40)+cnt])
          {
            position(output,(cnt&7)*5,(i<<1)+(cnt/8) );
            displayln(output,"*r",mail[(i*0x40)+cnt]);
            _mail[(i*0x40)+cnt]=mail[(i*0x40)+cnt];
          }
      position(output,0,8);
#define displayr(rnum,port,msg) { if (((port==16)&&int_work)||(r##rnum=read_port(port))!=_r##rnum) \
      {                                                                    \
         if (port==16)                                                     \
           displayln(output,msg"= *n/*n\n",int_work,r##rnum);              \
         else                                                               \
           displayln(output,msg"= *h\n",r##rnum);                          \
        _r##rnum=r##rnum;                                                  \
      } else displayln(output,"\n");            }
#define displayt(rnum,msg) { if ((r##rnum=*(short far *)0x0000046cL)!=_r##rnum)\
      {                                                                    \
        displayln(output,msg"= *h\n",r##rnum);                \
        _r##rnum=r##rnum;                                                  \
      }  else displayln(output,"\n");        }
      displayln(output,"DMA OUT CNT= *n*n DMA IN CNT= *n*n\n",
             inportb(0xca),inportb(0xca),
             inportb(0xce),inportb(0xce));
      displayln(output,"DMA OUT OFS= *n*n DMA IN OFS= *n*n\n",
             inportb(0xc8),inportb(0xc8),
             inportb(0xcc),inportb(0xcc));

      r1=read_port(STATUS);
      if (r1!=_r1)
      {
        displayln(output,"Status Out:*c*c*c*c*c*c*c*s In:*c*c*c*c*c*c*c*s\n",
                           (r1&0x8000)?' ':'E',
                           (r1&0x4000)?'N':' ',
                           (r1&0x2000)?'M':' ',
                           (r1&0x1000)?'I':' ',
                           (r1&0x800)?'X':' ',
                           (r1&0x400)?'B':' ',
                           (r1&0x200)?'m':'p',
                           (r1&0x100)?(char far *)"OBMT":(char far *)"OBFL",

                           (r1&0x80)?' ':'E',
                           (r1&0x40)?'N':' ',
                           (r1&0x20)?'M':' ',
                           (r1&0x10)?'I':' ',
                           (r1&0x8)?'X':' ',
                           (r1&0x4)?'B':' ',
                           (r1&0x2)?'A':' ',
                           (r1&0x1)?(char far *)"IBFL":(char far *)"IBMT");
        _r1=r1;
      }
      else displayln(output,"\n");
      displayr(2,2,   "Out Terminate ");
      displayr(3,10,  "In Terminate  ");
      displayr(4,16,  "Int Queue     ");
      displayr(5,4,   "Out TI        ");
      displayr(6,12,  "In TI         ");
      displayr(7,6,   "Out Select    ");
      displayr(8,14,  "In Select     ");
      displayt(9,     "Time          ");
      displayln(output,"Control : *b  Packets: *d",control,packet_cnt);
    }
  }
}

char go=false;

void main()
{
  char temp,far *num;
  short i,cnt;
  if (Get_environ("Debug"))
  {
    output=opendisplay(20,1,40,20
                      ,NO_CURSOR|BORDER|NEWLINE
                      ,0x70,0xe,0,"PCA_Diagnostics");
    clr_display(output,1);
    if (fork(INDEPENDANT))
      fork(INDEPENDANT);
  }
  else
  {
    fork(INDEPENDANT);
  }
  thread++;
  switch(thread)
  {
    case 1:break;
    case 2:while (!go) Relinquish(0L);
             do_output();
    case 3:while (!go) Relinquish(0L);

             do_diags();
    default:Relinquish(1);
  }
  for (cnt=0;cnt<MAX_DEVICES;cnt++)
  {
    char number[10];
    itoa(cnt,number);
    devices[cnt]=Get_environ(number);
    device_class[cnt]=0;
  }


          /* nodetrack */
  blank_work.Tracking.Side=0;
  blank_work.Tracking.start_time=0;
  blank_work.Tracking.Status=0;
  blank_work.Tracking.Source=NULL;
  blank_work.Tracking.next=NULL;
  blank_work.Tracking.prior=NULL;

  blank_work.Data=NULL;

         /* returndata */
  blank_work.Return.Opcode=0;
  blank_work.Return.Status=0;
  blank_work.Return.Byte_count=0;
  blank_work.Return.XStatus=0;
  blank_work.Return.Extended_Size=0;
  blank_work.Return.Extended_mail=NULL;

  blank_work.Node.Node_Address=0;

          /* data_track */
  blank_work.Data_handle.Preamble=NULL;
  blank_work.Data_handle.index=0;


  nodes=opendisplay(60,1,20,44
                   ,NO_CURSOR|BORDER|NEWLINE
                   ,0x02,0xf,0,"Work");

  base=atoi(Get_environ("PCA_BASE"));
  input_DMA=atoi(Get_environ("PCA_DMA_In"));
  output_DMA=atoi(Get_environ("PCA_DMA_Out"));
  PCA_num=atoi(Get_environ("PCA_device"));
  priority=atoi(Get_environ("PCA_priority"));
  DMP=atoi(Get_environ("PCA_DMP"));
  fill_name=Get_environ("Fill");
  config=0x8000|DMP|(PCA_num<<8)|((priority-3)<<4);
  for (i=0;i<4;i++)
    for (cnt=0;cnt<16;cnt++)
    {
      write_mail((i*0x40)+cnt,0);
      mail[(i*0x40)+cnt]=0;
      _mail[(i*0x40)+cnt]=0x1234;
    }


  IRQ=atoi(Get_environ("PCA_IRQ"));
  i=0;
  while ((read_port(STATUS)&1)&&(i<200))
  {
    read_port(DATA);
    i++;
  }
  out_port(INTR_QUEUE,read_port(INTR_QUEUE));
  out_port(OUT_CHANNEL,0);
  out_port(IN_CHANNEL,0);
  connect_int(IRQ);
  control=4;
  go=true;
  out_port(CONFIGURATION,config);
  do_input();
}


