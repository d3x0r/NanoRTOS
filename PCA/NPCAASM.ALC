.model small,C
.386

INCLUDE NPCAASM.INC
INCLUDE \common.ipc\OS.EQU

.data
extrn base:word
extrn control:word
extrn int_work:byte
extrn Allocate:dword
extrn do_transfer:byte
extrn process_control:dword
extrn Connect_Int:dword
extrn Disconnect_Int:dword
extrn device_class:byte
extrn filling:byte
extrn input_task:dword
extrn gettime:dword
extrn eventime:dword
extrn oddtime:dword
Read_Extra dw ReadRaw
           dw ReadEther
           dw ReadComm
Write_Extra dw WriteRaw

.code
public write_mail
public read_mailbox
public sread_mailbox
public connect_int
public out_port
public lread_mailbox
public read_port
public write_port
public copy_mail
public send_mail
;public Process_work
public read_all_mail
public disconnect
public outportb
public inportb
public shiftlong;
public shiftrong;

shiftlong proc near,number:dword,bits:byte
   les bx,number
   mov edx,es:[bx]
   mov cl,bits
   shl edx,cl
   mov es:[bx],edx
   ret
shiftlong endp

shiftrong proc near,number:dword,bits:byte
   les bx,number
   mov edx,es:[bx]
   mov cl,bits
   shr edx,cl
   mov es:[bx],edx
   ret
shiftrong endp


read_all_mail proc near,array:dword
  push di
  mov dx,base
  add dx,1ch
  mov ax,0
  out dx,ax
  les di,array
  add dx,2
  mov cx,256
top_all_mail:
  in ax,dx
  stosw
  loop top_all_mail
  pop di
  ret
read_all_mail endp

out_port proc near,port_ofs:word,data:word
    mov dx,base
    add dx,port_ofs
    mov ax,data
    out dx,ax
    ret
out_port endp

outportb proc near,port:word,data:byte
    mov dx,port
    mov al,data
    out dx,al
    ret
outportb endp

inportb proc near,port:word
    mov dx,port
    in al,dx
    cbw
    ret
inportb endp


read_port proc near,port_offset:word
    mov dx,base
    add dx,port_offset
    in ax,dx
    ret
read_port endp

write_port proc near,port_offset:word,value:word
    mov dx,base
    add dx,port_offset
    mov ax,value
    out dx,ax
    ret
write_port endp


send_mail proc near,mail_start:word,struct:dword
  push di
  mov dx,base
  add dx,mail_address
  mov ax,mail_start
  out dx,ax
  les di,struct
  add dx,mail_data-mail_address
  mov ax,es:[di].Return.Extended_Size
  add ax,Base_Return_mail
  xchg al,ah
  out dx,ax
  write_data es:[di].Return,Opcode,es:[di].Node,Rex      ;1
  write_data es:[di].Node,Node_Address                   ;2
  write_data es:[di].Return,StatusRD                       ;1
  write_data es:[di].Return,Byte_cnt                     ;2
  write_data es:[di].Return,XStatus                      ;1
  write_data es:[di].Node,FPI                            ;2
;  jmp leave_Write
  mov bx,es:[di].Node.Transport
  mov bl,device_class[bx]
  xor bh,bh
  cmp bx,MAX_WRITE_CLASSES
  jl write_switch
  mov bx,WRITE_RAW
write_switch:
  shl bx,1
  jmp Write_Extra[bx]
WriteRaw:
  mov cx,es:[di].Return.Extended_Size
  cmp cx,0
  jne send_extra
  jmp leave_Write
send_extra:
  push ds
  push si
  lds si,es:[di].Return.Extended_mail
send_extras:
  lodsw
  out dx,ax
  loop send_extras
  pop si
  pop ds
  jmp leave_Write

leave_Write:
  pop di
  ret
send_mail endp


copy_mail proc near,mail_start:word,struct:dword
  push di
  xor bx,bx
read_mail_now:
  mov dx,base
  add dx,mail_address
  mov ax,mail_start
  out dx,ax
  add dx,mail_data-mail_address ; we are already on the address so
                                ;       add differnce

  in ax,dx                  ;get mail size
  xchg al,ah                ;reverse it
  cmp ax,0                  ;test to see if there is mail
  jne contin_copy
  mov ax,false
  jmp leave_copy
contin_copy:
  push dx
  cmp ax,min_mail
  jge alloc_ok
retry_mail:
  cmp bx,-1
  je  exit_with_error
  mov bx,-1
  jmp read_mail_now
exit_with_error:
  mov ax,true
  jmp leave_copy
alloc_ok:
  cmp ax,max_mail
  ja retry_mail
  push ax
  mov ax,TYPE NodeStruc
  push ax
  call Allocate            ;allocate structure of size
  add sp,2
  les di,struct
  mov es:[di],ax            ;make pointer to structure=allocated mem
  mov es:[di+2],dx
  pop ax
  mov cx,ax                 ;store count of mail
  pop dx
  les di,es:[di]            ;move to point to structure.
  read_data es:[di].Node,Transport
;  cmp es:[di].Node.Transport,0ffh
;  jne contin_read
;  int 3;
;contin_read:
  read_data es:[di].Node,Channel
  read_data es:[di].Node,Node_Address
  read_data es:[di].Node,Rex
  read_data es:[di].Node,Options
  read_data es:[di].Node,Byte_Count
  read_data es:[di].Node,XOptions
  read_data es:[di].Node,FPI
;  push  es
;  add   di,Tracking.Start
;  push  di
;  call  gettime
;  pop   di
;  pop   es
;  sub   di,Start

  mov   bx,es:[di].Node.Transport
  mov   bl,device_class[bx]
  xor   bh,bh
  cmp   bx,MAX_READ_CLASSES
  jl    read_switch
  mov   bx,0
read_switch:
  shl   bx,1
  jmp   Read_Extra[bx]
ReadRaw:
  sub cx,min_mail
  jbe loop_done
  add di,Node.Info
Read_Raw_loop:
  in  ax,dx
  stosw
  loop Read_Raw_loop;
loop_done:
  jmp Zero_mail
ReadEther:
  BREAK;
  read_data_straight es:[di].Node.Info.Ether,SourceIP
  read_data_straight es:[di].Node.Info.Ether,DestIP
  read_data es:[di].Node.Info.Ether,SourceTCP
  read_data es:[di].Node.Info.Ether,DestTCP
  jmp Zero_mail
ReadComm:
  jmp Zero_mail
Zero_mail:
  mov dx,base              ;indicate that mail has been read
  add dx,mail_address
  mov ax,mail_start
  out dx,ax
  add dx,mail_data-mail_address
  xor ax,ax
  out dx,ax
  mov ax,true
leave_copy:
  pop di
  ret
copy_mail endp

short_rev MACRO
  lodsw
  xchg ah,al
  stosw
ENDM

long_rev MACRO
  lodsw
  xchg ah,al
  mov dx,ax
  lodsw
  xchg ah,al
  stosw
  mov ax,dx
  stosw
ENDM

skip_long MACRO
  add si,4
  add di,4
ENDM

Process_work proc near,struct:dword
  push ds
  push si
  push di
  les di,struct
  lds si,struct
;Transport
  short_rev
;Channel
  short_rev
;Node Address- no mod
  skip_long
;rex/return_code- need to swap values
  short_rev
;options
  short_rev
;byte_count
  short_rev
;extended options
  short_rev
;FPI
  long_rev
leave_process:
  pop di
  pop si
  pop ds
  ret
Process_work endp

read_mailbox proc near,mailbox:word
  mov dx,base
  add dx,mail_address
  mov ax,mailbox
  out dx,ax
  add dx,mail_data-mail_address
  in ax,dx
  ret
read_mailbox endp

write_mail proc near,mailbox:word,value:word
  mov dx,base
  add dx,mail_address
  mov ax,mailbox
  out dx,ax
  add dx,mail_data-mail_address
  mov ax,value
  out dx,ax
  ret
write_mail endp

sread_mailbox proc near,value:word
  mov dx,base
  add dx,mail_address
  mov ax,value
  out dx,ax
  add dx,mail_data-mail_address
  in ax,dx
  xchg al,ah
  ret
sread_mailbox endp

lread_mailbox proc near,which:word
  mov dx,base
  add dx,mail_address
  mov ax,which;
  out dx,ax
  add dx,mail_data-mail_address
  in ax,dx
  xchg al,ah
  push ax
  in ax,dx
  xchg al,ah
  pop dx
  ret
lread_mailbox endp

IRQ_ack dw 20h

last_IRQ dd 0h
_PCA_int proc far
  push dx
  push ax
  push bx
  push cx
  push ds
  mov   ax,@data
  mov   ds,ax
  cmp   filling,1h
  jne   okay
  jmp   return_now
okay:
  mov   cx,base
  add   cx,14h
  mov   bx,control
  mov dx,base                     ;IQ register
  add dx,10h
try_for_more:
  in  ax,dx                       ;get IQ
  and ax,0ffh
  jz restore

  test ax,02h
  jz   check_other_term
  or    int_work,EVENTERM
check_other_term:
  test ax,20h
  jz    checktcs
  or    int_work,ODDTERM
checktcs:
  test ax,08h
  jz nexttc
  xchg  dx,cx
  xchg  ax,bx
  and   ax,0fffeh
  out   dx,ax
  xchg  dx,cx
  xchg  ax,bx
  or    int_work,EVENTC
nexttc:
  test ax,80h
  jz actualselect
  xchg  dx,cx
  xchg  ax,bx
  and   ax,0fffdh
  out   dx,ax
  xchg  dx,cx
  xchg  ax,bx
  or    int_work,ODDTC
actualselect:
  test  ax,4
  jz    checkother
  or    int_work,EVENSEL
checkother:
  test  ax,40h
  jz    check_ti
  or    int_work,ODDSEL
check_ti:
  test  ax,01h
  jz    check_other_ti
  or    int_work,EVENTI
check_other_ti:
  test  ax,10h
  jz    clearcurrent
  cmp   do_transfer,0    ;check to see if there is a channel number to
                             ; transfer
  je    no_dma_start
  push  ax
  mov   al,do_transfer   ;get channel number
  mov   cs:do_transfer,0
  out   0d4h,al              ;start dma
  pop   ax
no_dma_start:
  or    int_work,ODDTI
  push  ax
  sub   dx,4
  in    ax,dx
  cmp   ax,88h
  jne   not_fill
  mov   filling,1h
not_fill:
  add   dx,4
  pop   ax
  je    restore
clearcurrent:
        out     dx,ax
        jmp     try_for_more
restore:
        push    es
        push    bx
        les     bx,process_control
        or      word ptr es:[bx],1           ;make task list scan from top NOW
        les     bx,input_task
        mov     word ptr es:[bx].status,0    ;zero input task status
        mov     word ptr es:[bx+2].status,0  ;zero input task status
        pop     bx
        pop     es
        mov     control,bx
return_now:
        push    es
        push    di
        test    int_work,EVENTC+EVENSEL+EVENTERM+EVENTI
        jz      test_odd
        push    seg     eventime
        push    offset     eventime
        call    gettime
        add     sp,4
test_odd:
        test    int_work,ODDTC+ODDSEL+ODDTERM+ODDTI
        jz      clear_int
        push    seg     oddtime
        push    offset     oddtime
        call    gettime
        add     sp,4
clear_int:
        pop     di
        pop     es
        mov     al,20h
        out     20h,al
        mov     dx,cs:IRQ_ack
        cmp     dx,0a0h
        jne     already_reset
        out     dx,al
already_reset:
        pop     ds
        pop     cx
        pop     bx
        pop     ax
        pop     dx
  iret
_PCA_int endp
IRQ_addr dw 0000h   ;0
         dw 0000h   ;1
         dw 000ah   ;2
         dw 000bh   ;3
         dw 000ch   ;4
         dw 000dh   ;5
         dw 000eh   ;6
         dw 000fh   ;7
         dw 0070h   ;8
         dw 0071h   ;9
         dw 0072h   ;10
         dw 0073h   ;11
         dw 0074h   ;12
         dw 0075h   ;13
         dw 0076h   ;14
         dw 0077h   ;15

irqbase_table   dw 20h  ;0
                dw 20h  ;1
                dw 20h  ;2
                dw 20h  ;3
                dw 20h  ;4
                dw 20h  ;5
                dw 20h  ;6
                dw 20h  ;7
                dw 0a0h  ;8
                dw 0a0h  ;9
                dw 0a0h  ;10
                dw 0a0h  ;11
                dw 0a0h  ;12
                dw 0a0h  ;13
                dw 0a0h  ;14
                dw 0a0h  ;15


connect_int proc near
;   Stack Frame
;
;
;              irq num
;        +2    near
;        bp  - bp
  push bp
  mov bp,sp
  mov bx,[bp+4]                              ;mov irq num to bx
  xor bh,bh
  shl bx,1                                 ;make bx a  word index
  mov di,[IRQ_addr+bx]
  push  bx
  push  di
  push  cs
  push  offset _PCA_int
  call  Connect_Int
  add   sp,6
  pop   bx

  mov ax,[irqbase_table+bx]                ;get ack port
  mov IRQ_ack,ax
  mov dx,ax
  inc dx                                   ;put IRQ mask port in dx
  shr bx,1                                 ;make bx the value
  and bx,7                                 ;mask off high bit, because the
                                           ;high IRQs are the same as low
  mov cx,bx
  mov bx,1
  shl bx,cl                                ;bx will contain the bits mask
                                           ;of the IRQ in question

  in al,dx                                 ;get prior mask
  or al,bl                                 ;turn on bit
  xor al,bl                                ;turn off bit
  out dx,al                                ;save mask
  pop bp
  ret

connect_int endp
disconnect proc near
;   Stack Frame
;
;
;              irq num
;        +2    near
;        bp  - bp
  push bp
  mov bp,sp
  mov bx,[bp+4]                              ;mov irq num to bx
  xor bh,bh
  shl bx,1                                 ;make bx a word index
  mov di,[IRQ_addr+bx]
  push  bx
  push  di
  push  cs
  push  offset _PCA_int
  call  Disconnect_Int
  add   sp,6
  pop   bx

  mov ax,[irqbase_table+bx]                ;get ack port
  mov IRQ_ack,ax
  mov dx,ax
  inc dx                                   ;put IRQ mask port in dx
  shr bx,1                                 ;make bx the value
  and bx,7                                 ;mask off high bit, because the
                                           ;high IRQs are the same as low
  mov cx,bx
  mov bx,1
  shl bx,cl                                ;bx will contain the bits mask
                                           ;of the IRQ in question
  in al,dx                                 ;get prior mask
  or al,bl                                 ;turn on bit
  out dx,al                                ;save mask
  pop bp
  ret

disconnect endp





END
